{"repo": "unicode-org/icu4x", "instance_id": "unicode-org__icu4x-6776", "language": "Rust", "difficulty": "medium", "task_type": "bugfix", "repo_type": "devtools", "base_commit": "d4eb34d9a0f6f09dae603a397e13a102b3cb5510", "patch": "diff --git a/utils/ixdtf/src/parsers/annotations.rs b/utils/ixdtf/src/parsers/annotations.rs\nindex 91347ce10fa..dc4610e18a8 100644\n--- a/utils/ixdtf/src/parsers/annotations.rs\n+++ b/utils/ixdtf/src/parsers/annotations.rs\n@@ -30,7 +30,7 @@ pub(crate) fn parse_annotation_set<'a, T: EncodingType>(\n     cursor: &mut Cursor<'a, T>,\n     handler: impl FnMut(Annotation<'a, T>) -> Option<Annotation<'a, T>>,\n ) -> ParserResult<AnnotationSet<'a, T>> {\n-    // Parse the first annotation.\n+    // Parse an optional TimeZoneAnnotation\n     let tz_annotation = timezone::parse_ambiguous_tz_annotation(cursor)?;\n \n     // Parse any `Annotations`\n\ndiff --git a/utils/ixdtf/src/parsers/timezone.rs b/utils/ixdtf/src/parsers/timezone.rs\nindex d0d101e7da8..9c4741f1404 100644\n--- a/utils/ixdtf/src/parsers/timezone.rs\n+++ b/utils/ixdtf/src/parsers/timezone.rs\n@@ -6,9 +6,9 @@\n \n use super::{\n     grammar::{\n-        is_a_key_char, is_a_key_leading_char, is_annotation_close,\n-        is_annotation_key_value_separator, is_annotation_open, is_ascii_sign, is_critical_flag,\n-        is_time_separator, is_tz_char, is_tz_leading_char, is_tz_name_separator, is_utc_designator,\n+        is_a_key_leading_char, is_annotation_close, is_annotation_key_value_separator,\n+        is_annotation_open, is_ascii_sign, is_critical_flag, is_time_separator, is_tz_char,\n+        is_tz_leading_char, is_tz_name_separator, is_utc_designator,\n     },\n     time::{parse_fraction, parse_hour, parse_minute_second},\n     Cursor,\n@@ -27,6 +27,13 @@ use crate::{\n \n // ==== Time Zone Annotation Parsing ====\n \n+/// We support two kinds of annotations here: annotations (e.g. `[u-ca=foo]`)\n+/// and \"time zone annotations\" (`[UTC]` or `[+05:30]`)\n+///\n+/// When parsing bracketed contents, we need to figure out which one we're dealing with.\n+///\n+/// This function returns a time zone annotation if we are dealing with a time zone,\n+/// otherwise it returns None (and the caller must handle non-tz annotations).\n pub(crate) fn parse_ambiguous_tz_annotation<'a, T: EncodingType>(\n     cursor: &mut Cursor<'a, T>,\n ) -> ParserResult<Option<TimeZoneAnnotation<'a, T>>> {\n@@ -46,35 +53,28 @@ pub(crate) fn parse_ambiguous_tz_annotation<'a, T: EncodingType>(\n         .peek_n(current_peek)?\n         .ok_or(ParseError::abrupt_end(\"AmbiguousAnnotation\"))?;\n \n-    if is_tz_leading_char(leading_char) || is_ascii_sign(leading_char) {\n-        // Ambigious start values when lowercase alpha that is shared between `TzLeadingChar` and `KeyLeadingChar`.\n-        if is_a_key_leading_char(leading_char) {\n-            let mut peek_pos = current_peek + 1;\n-            while let Some(ch) = cursor.peek_n(peek_pos)? {\n-                if is_tz_name_separator(ch) || (is_tz_char(ch) && !is_a_key_char(ch)) {\n-                    let tz = parse_tz_annotation(cursor)?;\n-                    return Ok(Some(tz));\n-                } else if is_annotation_key_value_separator(ch)\n-                    || (is_a_key_char(ch) && !is_tz_char(ch))\n-                {\n-                    return Ok(None);\n-                } else if is_annotation_close(ch) {\n-                    return Err(ParseError::InvalidAnnotation);\n-                }\n-\n-                peek_pos += 1;\n+    // Ambigious start values when lowercase alpha that is shared between `TzLeadingChar` and `KeyLeadingChar`.\n+    if is_a_key_leading_char(leading_char) {\n+        let mut peek_pos = current_peek + 1;\n+        // Go through looking for `=`\n+        while let Some(ch) = cursor.peek_n(peek_pos)? {\n+            if is_annotation_key_value_separator(ch) {\n+                // We have an `=` sign, this is a non-tz annotation\n+                return Ok(None);\n+            } else if is_annotation_close(ch) {\n+                // We found a `]` without an `=`, this is a time zone\n+                let tz = parse_tz_annotation(cursor)?;\n+                return Ok(Some(tz));\n             }\n-            return Err(ParseError::abrupt_end(\"AmbiguousAnnotation\"));\n+\n+            peek_pos += 1;\n         }\n+        Err(ParseError::abrupt_end(\"AmbiguousAnnotation\"))\n+    } else {\n+        // Unambiguously not a non-tz annotation, try parsing a tz annotation\n         let tz = parse_tz_annotation(cursor)?;\n-        return Ok(Some(tz));\n+        Ok(Some(tz))\n     }\n-\n-    if is_a_key_leading_char(leading_char) {\n-        return Ok(None);\n-    };\n-\n-    Err(ParseError::AnnotationChar)\n }\n \n fn parse_tz_annotation<'a, T: EncodingType>(\n", "test_patch": "diff --git a/utils/ixdtf/src/parsers/tests.rs b/utils/ixdtf/src/parsers/tests.rs\nindex 777d127e7a5..a4edc6e583b 100644\n--- a/utils/ixdtf/src/parsers/tests.rs\n+++ b/utils/ixdtf/src/parsers/tests.rs\n@@ -279,14 +279,6 @@ fn invalid_annotations() {\n         \"Invalid annotation parsing: \\\"{bad_value}\\\" should fail to parse.\"\n     );\n \n-    let bad_value = \"2021-01-29 02:12:48+01:00:00[u][u-ca=iso8601]\";\n-    let err = IxdtfParser::from_str(bad_value).parse();\n-    assert_eq!(\n-        err,\n-        Err(ParseError::InvalidAnnotation),\n-        \"Invalid annotation parsing: \\\"{bad_value}\\\" should fail to parse.\"\n-    );\n-\n     let bad_value = \"2021-01-29 02:12:48+01:00:00[u-ca=iso8601][!foo=bar]\";\n     let err = IxdtfParser::from_str(bad_value).parse();\n     assert_eq!(\n@@ -586,6 +578,34 @@ fn valid_unambiguous_time() {\n     }\n }\n \n+#[test]\n+fn ambiguous_annotations() {\n+    const TESTS_TIMEZONE: &[&str] = &[\n+        // Starts with capital, must be timezone\n+        \"2020-01-01[Asia/Kolkata]\",\n+        // Has a slash\n+        \"2020-01-01[asia/kolkata]\",\n+        \"2020-01-01[cet]\",\n+        // both annotation and tz\n+        \"2021-01-29 02:12:48+01:00:00[u][u-ca=iso8601]\",\n+    ];\n+    const TESTS_ANNOTATIONS: &[&str] = &[\n+        // Calendar\n+        \"2020-01-01[u-ca=foo]\",\n+        // Nonesense annotations (must still parse)\n+        \"2020-01-01[c-et=foo]\",\n+        \"2020-01-01[cet=foo]\",\n+    ];\n+    for test in TESTS_TIMEZONE {\n+        let result = IxdtfParser::from_str(test).parse().expect(test);\n+        assert!(result.tz.is_some());\n+    }\n+    for test in TESTS_ANNOTATIONS {\n+        let result = IxdtfParser::from_str(test).parse().expect(test);\n+        assert!(result.tz.is_none());\n+    }\n+}\n+\n #[test]\n fn temporal_valid_instant_strings() {\n     let instants = [\n", "problem_statement": "ixdtf should parse timezone annotation \"[cet]\" as a timezone\nCurrently, parsing zoned datetime strings like `2020-01-01[cet]` will fail in `parse_ambiguous_tz_annotation` at https://github.com/unicode-org/icu4x/blob/d4eb34d9a0f6f09dae603a397e13a102b3cb5510/utils/ixdtf/src/parsers/timezone.rs#L62, since the `c` in `cet` matches [AKeyLeadingChar](https://tc39.es/proposal-temporal/#prod-AKeyLeadingChar).\n\nI guess this function is attempting to deal with `[u-ca=foo]` and other annotations. I think instead of returning  an error on `is_annotation_close` we should be attempting to parse it as a timezone.\n\n\ncc @nekevss", "created_at": "2025-07-29T00:46:27", "FAIL_TO_PASS": ["parsers::tests::ambiguous_annotations"], "PASS_TO_PASS": ["parsers::tests::bad_extended_year", "parsers::tests::duplicate_same_calendar", "parsers::tests::duration_exceeds_range", "parsers::tests::duration_fraction_extended", "parsers::tests::good_extended_year_parsing", "parsers::tests::good_zoned_date_time", "parsers::tests::bad_zoned_date_time", "parsers::tests::good_annotations_date_time", "parsers::tests::invalid_ambiguous_time", "parsers::tests::invalid_annotations", "parsers::tests::invalid_calendar_annotations", "parsers::tests::invalid_day_for_month", "parsers::tests::invalid_month", "parsers::tests::invalid_month_day", "parsers::tests::invalid_offset", "parsers::tests::invalid_time", "parsers::tests::invalid_year_month", "parsers::tests::maximum_duration_fraction", "parsers::tests::subsecond_string_tests", "parsers::tests::subseconds_parsing_extended_femtoseconds", "parsers::tests::subseconds_parsing_extended_nanoseconds", "parsers::tests::subseconds_parsing_extended_picoseconds", "parsers::tests::subseconds_parsing_extended_truncated", "parsers::tests::maximum_duration_units", "parsers::tests::temporal_date_time_max", "parsers::tests::temporal_duration_parsing", "parsers::tests::temporal_invalid_durations", "parsers::tests::temporal_invalid_iso_datetime_strings", "parsers::tests::temporal_month_day", "parsers::tests::temporal_parser_basic", "parsers::tests::temporal_time", "parsers::tests::temporal_valid_instant_strings", "parsers::tests::temporal_year_month", "parsers::tests::test_bad_date", "parsers::tests::test_bad_time_spec_separator", "parsers::tests::test_correct_datetime", "parsers::tests::test_hour_utc_offset", "parsers::tests::test_offset_annotation", "parsers::tests::test_zulu_offset", "parsers::tests::tz_parser_offset_invalid", "parsers::tests::utf16_basic_test", "parsers::tests::valid_calendar_annotations", "parsers::tests::valid_unambiguous_time"], "environment_config": "{'build': [], 'test_cmd': 'cargo test -p ixdtf -- --nocapture', 'pre_install': ['apt-get update -y', 'apt-get install -y clang'], 'docker_specs': {'rust_version': '1.85'}, 'log_parser_name': 'cargo', 'no_test_directives': True}", "version": "6776"}
